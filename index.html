<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fogline, card-based micro-wargame</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 10px;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #game-area {
            position: relative;
            width: 100vw;
            margin-bottom: 20px auto;
            border: 0px solid #ccc;
            background-color: #e8e8e8;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #board {
            display: inline-grid;
            padding: 27.5px;
        }

        .card {
            width: 75px; /* Portrait width */
            height: 105px; /* Portrait height */
            border: 1px solid #333;
            border-radius: 5px;
            position: relative; /* Needed for absolute positioning of edges */
            cursor: default; /* Default cursor */
            background-color: #fff;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Pushes stats down */
            align-items: center;
            padding: 5px;
            box-sizing: border-box;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            margin: 2.5px; /* Space between cards */
            overflow: hidden; /* Hide overflowing edge content if any */
        }

        .card.selected {
            border: 2px solid gold;
            box-shadow: 0 0 10px gold;
        }

        .card.hidden {
            background-color: #888; /* Grey for hidden */
            color: #ccc;
        }

        .card.hidden .unit-name,
        .card.hidden .stats { /* Keep terrain edges visible */
            visibility: hidden;
        }

        .unit-name {
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            margin-top: 5px;
            z-index: 1; /* Above terrain edges */
        }

        .stats {
            font-size: 12px;
            text-align: center;
            width: 100%;
            display: flex;
            justify-content: space-around;
            margin-bottom: 5px;
            z-index: 1; /* Above terrain edges */
        }

        .stats span {
            display: inline-block;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .attack { background-color: #ffcccb; border: 1px solid #f08080; }
        .defense { background-color: #add8e6; border: 1px solid #87ceeb; }

        /* --- Cursor and Hover based on Action State --- */
        .selectable-initial { cursor: pointer; }
        .selectable-move { cursor: pointer; }
        .selectable-attack { cursor: crosshair; }
        .not-selectable { cursor: not-allowed; }

        .selectable-initial:hover,
        .selectable-move:hover,
        .selectable-attack:hover {
            transform: translateY(-3px);
            box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.3);
        }

        /* --- Terrain Edge Display --- */
        .terrain-edges {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Don't interfere with clicks */
            z-index: 0; /* Behind unit info */
        }
        .terrain-edge {
            position: absolute;
            font-size: 18px; /* Emoji size */
            line-height: 1;
            opacity: 0.8; /* Slightly faded */
        }
        .edge-top { top: 2px; left: 50%; transform: translateX(-50%); }
        .edge-right { top: 50%; right: 2px; transform: translateY(-50%); }
        .edge-bottom { bottom: 2px; left: 50%; transform: translateX(-50%); }
        .edge-left { top: 50%; left: 2px; transform: translateY(-50%); }

        /* Removed terrain background hints */

        .player1 { border-left: 5px solid #4a90e2; }
        .player2 { border-left: 5px solid #e94e77; }

        #info, #controls {
            margin-top: 15px;
            margin-bottom: 15px;
            text-align: center;
            width: 100%;
        }
        #info span { margin: 0 15px; font-weight: bold; }
        .player1-text { color: #4a90e2; }
        .player2-text { color: #e94e77; }

        button {
            padding: 8px 15px; font-size: 14px; cursor: pointer;
            background-color: #5cb85c; color: white; border: none;
            border-radius: 4px; margin: 5px;
        }
        button:hover { background-color: #4cae4c; }

        #defeated-units {
            margin-top: 20px; padding: 10px; border: 1px dashed #aaa;
            min-height: 120px; width: 90%; max-width: 1000px;
            background-color: #f8f8f8; display: flex; flex-wrap: wrap;
            align-items: flex-start; gap: 5px;
        }
        #defeated-units h4 {
            width: 100%; text-align: center; margin: 0 0 10px 0; color: #555;
        }
        .defeated-card {
            width: 60px; height: 90px; border: 1px solid #666;
            border-radius: 3px; background-color: #ccc; display: flex;
            flex-direction: column; justify-content: space-between;
            align-items: center; padding: 3px; box-sizing: border-box;
            font-size: 10px; position: relative; /* For edges */
        }
        .defeated-card .unit-name { font-size: 11px; font-weight: bold; margin-top: 3px; z-index: 1; }
        .defeated-card .stats { font-size: 9px; margin-bottom: 3px; z-index: 1; }
        /* Defeated cards also show edges */
        .defeated-card .terrain-edges { visibility: visible !important; } /* Override hidden */
        .defeated-card .terrain-edge { font-size: 12px; opacity: 0.6; }
        .defeated-card .edge-top { top: 1px; }
        .defeated-card .edge-right { right: 1px; }
        .defeated-card .edge-bottom { bottom: 1px; }
        .defeated-card .edge-left { left: 1px; }

        .defeated-card.player1 { border-left: 3px solid #4a90e2; }
        .defeated-card.player2 { border-left: 3px solid #e94e77; }

    </style>
</head>

<body>
    <h2 style="text-align:center;">Fogline, card-based micro-wargame</h2>

    <div id="info">Loading...</div>

    <div id="game-area">
        <div id="board"></div>
    </div>

    <div id="controls">
        <button onclick="resetGame()">Reset Game</button>
        <span id="message-log" style="margin-left: 20px; color: #333; font-style: italic;"></span>
    </div>

    <div id="defeated-units">
        <h4>Defeated Units</h4>
    </div>

    <script>
        let board = []; // Stores card objects { id, unit, terrain: {top, right, bottom, left}, hidden, owner, gridX, gridY, element }
        let currentPlayer = 1;
        let playerUnits = {}; // { 1: [{unit, terrainCardIndex}, ...], 2: [...] }
        let placedPositions = new Set(); // Store "x_y" strings
        let selectedCardIndex = null; // Index in the board array
        let isResolvingAttack = false; // Prevent actions during attack resolution delay
        let defeatedUnits = []; // Stores { unit, terrain: {top, right, bottom, left}, owner } of defeated units
        let nextCardId = 0; // Unique ID for each card

        const START_GRID_COORD = 10; // Start placing cards around grid cell 10,10

        // Terrain Types & Emojis
        const TERRAIN_TYPES = {
            PLAINS: 'Plains',
            FOREST: 'Forest',
            MOUNTAIN: 'Mountain'
        };
        const TERRAIN_EMOJIS = {
            [TERRAIN_TYPES.PLAINS]: 'üèûÔ∏è',
            [TERRAIN_TYPES.FOREST]: 'üå≤',
            [TERRAIN_TYPES.MOUNTAIN]: '‚õ∞Ô∏è'
        };

        // Unit Stats (Movement based on terrain *type*)
        const unitStats = {
            'Mobile Command': { attack: 1, defense: 2, quantity: 1, canTraverse: [TERRAIN_TYPES.PLAINS] },
            'Tank': { attack: 4, defense: 4, quantity: 2, canTraverse: [TERRAIN_TYPES.PLAINS] },
            'Infantry': { attack: 3, defense: 3, quantity: 3, canTraverse: [TERRAIN_TYPES.PLAINS, TERRAIN_TYPES.FOREST, TERRAIN_TYPES.MOUNTAIN] },
            'Artillery': { attack: 5, defense: 1, quantity: 1, canTraverse: [TERRAIN_TYPES.PLAINS] },
            'Special Ops': { attack: 3, defense: 1, quantity: 1, canTraverse: [TERRAIN_TYPES.PLAINS, TERRAIN_TYPES.FOREST, TERRAIN_TYPES.MOUNTAIN] }
        };

        // Terrain Rules (Defense bonus based on type)
        const terrainRules = {
            [TERRAIN_TYPES.PLAINS]: { defenseBonus: 0 },
            [TERRAIN_TYPES.FOREST]: { defenseBonus: 1 },
            [TERRAIN_TYPES.MOUNTAIN]: { defenseBonus: 0 }
        };

        // The 8 Fixed Terrain Cards (Top, Right, Bottom, Left)
        const fixedTerrainCards = [
            { top: TERRAIN_TYPES.PLAINS, right: TERRAIN_TYPES.FOREST, bottom: TERRAIN_TYPES.PLAINS, left: TERRAIN_TYPES.FOREST },
            { top: TERRAIN_TYPES.PLAINS, right: TERRAIN_TYPES.MOUNTAIN, bottom: TERRAIN_TYPES.PLAINS, left: TERRAIN_TYPES.MOUNTAIN },
            { top: TERRAIN_TYPES.FOREST, right: TERRAIN_TYPES.PLAINS, bottom: TERRAIN_TYPES.FOREST, left: TERRAIN_TYPES.PLAINS },
            { top: TERRAIN_TYPES.MOUNTAIN, right: TERRAIN_TYPES.PLAINS, bottom: TERRAIN_TYPES.MOUNTAIN, left: TERRAIN_TYPES.PLAINS },
            { top: TERRAIN_TYPES.FOREST, right: TERRAIN_TYPES.FOREST, bottom: TERRAIN_TYPES.PLAINS, left: TERRAIN_TYPES.MOUNTAIN },
            { top: TERRAIN_TYPES.MOUNTAIN, right: TERRAIN_TYPES.MOUNTAIN, bottom: TERRAIN_TYPES.PLAINS, left: TERRAIN_TYPES.FOREST },
            { top: TERRAIN_TYPES.FOREST, right: TERRAIN_TYPES.MOUNTAIN, bottom: TERRAIN_TYPES.FOREST, left: TERRAIN_TYPES.PLAINS },
            { top: TERRAIN_TYPES.MOUNTAIN, right: TERRAIN_TYPES.FOREST, bottom: TERRAIN_TYPES.MOUNTAIN, left: TERRAIN_TYPES.PLAINS }
        ];

        function getUnitList() {
            const units = [];
            for (const type in unitStats) {
                for (let i = 0; i < unitStats[type].quantity; i++) {
                    units.push(type);
                }
            }
            return units; // Should be 8 units total
        }

        // Fisher-Yates Shuffle
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Place card with 4-sided terrain
        function placeCard(gridX, gridY, owner, unit, terrainData) {
            const cardId = nextCardId++;
            const card = { id: cardId, unit, terrain: terrainData, hidden: true, owner, gridX, gridY, element: null };
            board.push(card);
            const gridKey = `${gridX}_${gridY}`;
            placedPositions.add(gridKey);

            const boardDiv = document.getElementById('board');
            const cardDiv = document.createElement('div');
            // Remove terrain-X class, add player class
            cardDiv.className = `card hidden player${owner}`;
            cardDiv.style.gridColumn = gridX;
            cardDiv.style.gridRow = gridY;
            cardDiv.dataset.id = cardId;
            cardDiv.onclick = () => handleCardClick(cardId);

            // Add structure for content including terrain edges
            cardDiv.innerHTML = `
                <div class="terrain-edges">
                    <span class="terrain-edge edge-top">${TERRAIN_EMOJIS[terrainData.top]}</span>
                    <span class="terrain-edge edge-right">${TERRAIN_EMOJIS[terrainData.right]}</span>
                    <span class="terrain-edge edge-bottom">${TERRAIN_EMOJIS[terrainData.bottom]}</span>
                    <span class="terrain-edge edge-left">${TERRAIN_EMOJIS[terrainData.left]}</span>
                </div>
                <div class="unit-name">${unit || '?'}</div>
                <div class="stats">
                    <span class="attack">A: ?</span>
                    <span class="defense">D: ?</span>
                </div>
                <!-- Removed single terrain-name div -->
            `;

            boardDiv.appendChild(cardDiv);
            card.element = cardDiv;
            return card;
        }

        function findCardIndexById(id) {
            return board.findIndex(card => card && card.id === id);
        }
        function findCardById(id) {
            return board.find(card => card && card.id === id);
        }
        function findCardByGrid(gridX, gridY) {
            return board.find(card => card && card.gridX === gridX && card.gridY === gridY);
        }

        // Helper to get direction and opposite direction between adjacent cards
        function getDirectionInfo(card1, card2) {
            if (!card1 || !card2) return null;
            const dx = card2.gridX - card1.gridX;
            const dy = card2.gridY - card1.gridY;

            if (dx === 1 && dy === 0) return { direction: 'right', opposite: 'left' };
            if (dx === -1 && dy === 0) return { direction: 'left', opposite: 'right' };
            if (dx === 0 && dy === 1) return { direction: 'bottom', opposite: 'top' }; // Grid Y increases downwards
            if (dx === 0 && dy === -1) return { direction: 'top', opposite: 'bottom' }; // Grid Y decreases upwards
            return null; // Not adjacent or same card
        }

        // Helper to check if a unit can traverse a specific terrain type
        function canUnitTraverse(unitName, terrainType) {
            if (!unitName || !terrainType) return false;
            const stats = unitStats[unitName];
            return stats && stats.canTraverse.includes(terrainType);
        }


        function handleCardClick(cardId) {
            if (isResolvingAttack) return;

            const clickedCardIndex = findCardIndexById(cardId);
            if (clickedCardIndex === -1) return;
            const clickedCard = board[clickedCardIndex];

            logMessage(""); // Clear previous message

            if (selectedCardIndex === null) {
                // --- Selecting a unit ---
                if (clickedCard.owner !== currentPlayer) {
                    logMessage("Cannot select opponent's card."); return;
                }
                if (!clickedCard.unit) {
                    logMessage("Cannot select an empty space."); return;
                }

                if (clickedCard.hidden) {
                    clickedCard.hidden = false;
                    logMessage(`Player ${currentPlayer} revealed ${clickedCard.unit}.`);
                }

                selectedCardIndex = clickedCardIndex;
                board.forEach(c => c.element?.classList.remove('selected'));
                clickedCard.element.classList.add('selected');

            } else {
                // --- Target selected ---
                const attackerCard = board[selectedCardIndex];

                if (clickedCardIndex === selectedCardIndex) { // Deselecting
                    selectedCardIndex = null;
                    attackerCard.element.classList.remove('selected');
                    logMessage("Card deselected.");
                    updateUI();
                    return;
                }

                const directionInfo = getDirectionInfo(attackerCard, clickedCard);
                if (!directionInfo) {
                    logMessage("Target is not adjacent."); return;
                }

                // --- Check Movement Legality ---
                // Unit must be able to traverse the terrain on the *destination* card's edge
                // that faces the *origin* card.
                const entryTerrainType = clickedCard.terrain[directionInfo.opposite];
                if (!canUnitTraverse(attackerCard.unit, entryTerrainType)) {
                    logMessage(`${attackerCard.unit} cannot enter via ${entryTerrainType} (${directionInfo.opposite} edge of target).`);
                    return;
                }

                // --- Process Action: Move or Attack ---
                if (clickedCard.owner === currentPlayer) {
                    logMessage("Cannot move/attack your own unit."); return;
                }

                if (!clickedCard.unit) {
                    // --- Moving to empty adjacent tile ---
                    logMessage(`Player ${currentPlayer} moved ${attackerCard.unit} via ${entryTerrainType}.`);

                    // Update board state - Data moves
                    clickedCard.unit = attackerCard.unit;
                    clickedCard.owner = attackerCard.owner;
                    clickedCard.hidden = false; // Moved unit is revealed

                    attackerCard.unit = null;
                    attackerCard.owner = null;
                    attackerCard.hidden = true; // Previous spot becomes empty/hidden

                    // Grid positions remain, data swapped. placedPositions doesn't need update here.

                    selectedCardIndex = null;
                    currentPlayer = currentPlayer === 1 ? 2 : 1;
                    isResolvingAttack = false;

                } else {
                    // --- Attacking an enemy unit ---
                    logMessage(`Player ${currentPlayer}'s ${attackerCard.unit} attacks ${clickedCard.unit}...`);
                    isResolvingAttack = true;

                    if (clickedCard.hidden) {
                        clickedCard.hidden = false;
                        logMessage(`Revealed defender: ${clickedCard.unit}.`);
                        updateUI(); // Show revealed defender
                    }

                    setTimeout(() => {
                        resolveAttack(selectedCardIndex, clickedCardIndex);
                        isResolvingAttack = false; // Unlock after resolution
                    }, 1500);
                }
                // Update UI after move or before attack resolution starts
                updateUI();
            }
            // Update UI if only selecting/deselecting
            if (!isResolvingAttack) updateUI();
        }

        function resolveAttack(attackerIndex, defenderIndex) {
            const attackerCard = board[attackerIndex];
            const defenderCard = board[defenderIndex];

            if (!attackerCard || !attackerCard.unit || !defenderCard || !defenderCard.unit) {
                logMessage("Attack cancelled - unit missing.");
                isResolvingAttack = false;
                selectedCardIndex = null;
                updateUI();
                return;
            }

            const attackerStats = unitStats[attackerCard.unit];
            const defenderStats = unitStats[defenderCard.unit];

            // Determine defense bonus based on the defender's edge facing the attacker
            const directionInfo = getDirectionInfo(attackerCard, defenderCard);
            const defenseEdgeTerrain = defenderCard.terrain[directionInfo.opposite];
            const terrainBonus = terrainRules[defenseEdgeTerrain]?.defenseBonus || 0;

            const attackValue = attackerStats.attack;
            const defenseValue = defenderStats.defense + terrainBonus;

            logMessage(`${attackerCard.unit} (A:${attackValue}) vs ${defenderCard.unit} (D:${defenderStats.defense} + ${terrainBonus} Bonus = ${defenseValue}) attacking via ${defenseEdgeTerrain}`);

            let winner, loser;
            let attackerWins = attackValue >= defenseValue; // Attacker wins ties

            if (attackerWins) {
                winner = attackerCard;
                loser = defenderCard;
                logMessage(`Attacker wins! ${winner.unit} defeats ${loser.unit}.`);

                defeatedUnits.push({ unit: loser.unit, terrain: loser.terrain, owner: loser.owner });

                // Update board: Attacker data moves to defender's card object
                defenderCard.unit = attackerCard.unit;
                defenderCard.owner = attackerCard.owner;
                defenderCard.hidden = false; // Winner is revealed

                // Clear attacker's original card object data
                attackerCard.unit = null;
                attackerCard.owner = null;
                attackerCard.hidden = true; // Visually empty

            } else { // Defender wins
                winner = defenderCard;
                loser = attackerCard;
                logMessage(`Defender wins! ${winner.unit} defeats ${loser.unit}.`);

                defeatedUnits.push({ unit: loser.unit, terrain: loser.terrain, owner: loser.owner });

                // Update board: Defender holds, clear attacker's card object data
                attackerCard.unit = null;
                attackerCard.owner = null;
                attackerCard.hidden = true; // Visually empty

                // Defender remains revealed
                defenderCard.hidden = false;
            }

            // Check for win conditions
            const commandUnit = 'Mobile Command';
            const remainingUnitsP1 = board.filter(c => c && c.owner === 1 && c.unit && c.unit !== commandUnit).length;
            const remainingUnitsP2 = board.filter(c => c && c.owner === 2 && c.unit && c.unit !== commandUnit).length;
            const commandP1 = board.find(c => c && c.unit === commandUnit && c.owner === 1);
            const commandP2 = board.find(c => c && c.unit === commandUnit && c.owner === 2);

            let gameOver = false;
            if (!commandP2) {
                logMessage(`Player 1 wins by capturing the Mobile Command!`); gameOver = true;
            } else if (!commandP1) {
                logMessage(`Player 2 wins by capturing the Mobile Command!`); gameOver = true;
            } else if (remainingUnitsP2 === 0 && commandP2) { // Check command still exists
                logMessage(`Player 1 wins by eliminating all other movable units!`); gameOver = true;
            } else if (remainingUnitsP1 === 0 && commandP1) { // Check command still exists
                logMessage(`Player 2 wins by eliminating all other movable units!`); gameOver = true;
            }

            selectedCardIndex = null;
            if (!gameOver) {
                currentPlayer = currentPlayer === 1 ? 2 : 1;
            } else {
                isResolvingAttack = true; // Keep locked if game over
            }

            updateUI();
        }

        // isAdjacent check remains the same (based on grid)
        function isAdjacent(card1, card2) {
            if (!card1 || !card2) return false;
            const dx = Math.abs(card1.gridX - card2.gridX);
            const dy = Math.abs(card1.gridY - card2.gridY);
            return (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
        }

        function updateUI() {
            const attackerCard = selectedCardIndex !== null ? board[selectedCardIndex] : null;

            board.forEach((card, i) => {
                if (!card || !card.element) return; // Skip removed/missing

                const div = card.element;
                // Reset base classes and remove selectable states
                div.className = `card player${card.owner || 0}`; // Base classes first
                div.classList.remove('selectable-initial', 'selectable-move', 'selectable-attack', 'not-selectable', 'selected', 'hidden'); // Clear states

                if (card.hidden) div.classList.add('hidden');
                if (i === selectedCardIndex) div.classList.add('selected');

                // --- Determine Selectable State ---
                if (selectedCardIndex === null) { // Selecting initial unit
                    if (card.owner === currentPlayer && card.unit) {
                        div.classList.add('selectable-initial');
                    } else {
                        div.classList.add('not-selectable');
                    }
                } else { // Unit selected, selecting target
                    if (i === selectedCardIndex) {
                        div.classList.add('not-selectable'); // Can't target self
                    } else {
                        const directionInfo = getDirectionInfo(attackerCard, card);
                        if (directionInfo) { // Is adjacent
                            const entryTerrainType = card.terrain[directionInfo.opposite];
                            if (canUnitTraverse(attackerCard.unit, entryTerrainType)) {
                                if (card.unit === null) { // Empty, valid square
                                    div.classList.add('selectable-move');
                                } else if (card.owner !== currentPlayer) { // Enemy unit
                                    div.classList.add('selectable-attack');
                                } else { // Own unit
                                    div.classList.add('not-selectable');
                                }
                            } else { // Invalid terrain edge
                                div.classList.add('not-selectable');
                            }
                        } else { // Not adjacent
                            div.classList.add('not-selectable');
                        }
                    }
                }
                // --- End Selectable State ---

                // Update Content (Unit Name, Stats, Terrain Edges)
                const unitNameDiv = div.querySelector('.unit-name');
                const statsDiv = div.querySelector('.stats');
                const attackSpan = statsDiv.querySelector('.attack');
                const defenseSpan = statsDiv.querySelector('.defense');
                const terrainEdgesDiv = div.querySelector('.terrain-edges');
                const edgeSpans = {
                    top: terrainEdgesDiv.querySelector('.edge-top'),
                    right: terrainEdgesDiv.querySelector('.edge-right'),
                    bottom: terrainEdgesDiv.querySelector('.edge-bottom'),
                    left: terrainEdgesDiv.querySelector('.edge-left'),
                };

                // Update terrain emojis (always visible unless card.hidden)
                edgeSpans.top.textContent = TERRAIN_EMOJIS[card.terrain.top];
                edgeSpans.right.textContent = TERRAIN_EMOJIS[card.terrain.right];
                edgeSpans.bottom.textContent = TERRAIN_EMOJIS[card.terrain.bottom];
                edgeSpans.left.textContent = TERRAIN_EMOJIS[card.terrain.left];

                if (card.unit && !card.hidden) {
                    unitNameDiv.textContent = card.unit;
                    const stats = unitStats[card.unit];
                    attackSpan.textContent = `A: ${stats.attack}`;
                    defenseSpan.textContent = `D: ${stats.defense}`;
                    unitNameDiv.style.visibility = 'visible';
                    statsDiv.style.visibility = 'visible';
                    terrainEdgesDiv.style.visibility = 'visible'; // Ensure edges are visible
                } else if (card.unit && card.hidden) {
                    unitNameDiv.textContent = '?';
                    attackSpan.textContent = `A: ?`;
                    defenseSpan.textContent = `D: ?`;
                    unitNameDiv.style.visibility = 'hidden';
                    statsDiv.style.visibility = 'hidden';
                    terrainEdgesDiv.style.visibility = 'visible'; // KEEP edges visible
                } else { // Empty spot
                    unitNameDiv.textContent = '';
                    attackSpan.textContent = `A: -`;
                    defenseSpan.textContent = `D: -`;
                    unitNameDiv.style.visibility = 'hidden';
                    statsDiv.style.visibility = 'hidden';
                    terrainEdgesDiv.style.visibility = 'visible'; // Show terrain even if empty
                    div.classList.add('hidden'); // Make empty spots look like fog
                }
            });

            // Update Info Bar
            const infoDiv = document.getElementById('info');
            const p1Units = board.filter(c => c && c.owner === 1 && c.unit).length;
            const p2Units = board.filter(c => c && c.owner === 2 && c.unit).length;
            infoDiv.innerHTML = `
                <span class="player1-text">Player 1 Units: ${p1Units}</span> |
                <span class="${currentPlayer === 1 ? 'player1-text' : 'player2-text'}">Current Turn: Player ${currentPlayer}</span> |
                <span class="player2-text">Player 2 Units: ${p2Units}</span>
             `;

            // Update Defeated Units Area
            const defeatedDiv = document.getElementById('defeated-units');
            defeatedDiv.innerHTML = '<h4>Defeated Units</h4>'; // Clear previous
            defeatedUnits.forEach(defeated => {
                const defeatedCardDiv = document.createElement('div');
                defeatedCardDiv.className = `defeated-card player${defeated.owner}`;
                const stats = unitStats[defeated.unit];
                const attack = stats ? stats.attack : '?';
                const defense = stats ? stats.defense : '?';
                defeatedCardDiv.innerHTML = `
                    <div class="terrain-edges">
                       <span class="terrain-edge edge-top">${TERRAIN_EMOJIS[defeated.terrain.top]}</span>
                       <span class="terrain-edge edge-right">${TERRAIN_EMOJIS[defeated.terrain.right]}</span>
                       <span class="terrain-edge edge-bottom">${TERRAIN_EMOJIS[defeated.terrain.bottom]}</span>
                       <span class="terrain-edge edge-left">${TERRAIN_EMOJIS[defeated.terrain.left]}</span>
                    </div>
                    <div class="unit-name">${defeated.unit}</div>
                    <div class="stats">
                       <span class="attack">A:${attack}</span> <span class="defense">D:${defense}</span>
                    </div>
                    <!-- No single terrain name -->`;
                defeatedDiv.appendChild(defeatedCardDiv);
            });
        }

        function logMessage(msg) {
            document.getElementById('message-log').textContent = msg;
            console.log(msg);
        }

        function resetGame() {
            logMessage("Setting up new game with 4-sided terrain...");
            board = [];
            placedPositions.clear();
            selectedCardIndex = null;
            isResolvingAttack = false;
            defeatedUnits = [];
            nextCardId = 0;
            document.getElementById('board').innerHTML = '';
            document.getElementById('defeated-units').innerHTML = '<h4>Defeated Units</h4>';

            // Prepare unit lists and terrain card indices (0-7) for each player
            playerUnits = { 1: [], 2: [] };
            const unitsP1 = shuffle(getUnitList());
            const terrainIndicesP1 = shuffle([...Array(8).keys()]); // Shuffle indices [0, 1, ..., 7]
            const unitsP2 = shuffle(getUnitList());
            const terrainIndicesP2 = shuffle([...Array(8).keys()]); // Shuffle indices [0, 1, ..., 7]

            for (let i = 0; i < 8; i++) {
                playerUnits[1].push({ unit: unitsP1[i], terrainCardIndex: terrainIndicesP1[i] });
                playerUnits[2].push({ unit: unitsP2[i], terrainCardIndex: terrainIndicesP2[i] });
            }

            // --- Automatic Placement (Simplified using Grid) ---
            const startGridX = START_GRID_COORD;
            const startGridY = START_GRID_COORD;
            const firstPairP1 = playerUnits[1].pop();
            const firstTerrainDataP1 = fixedTerrainCards[firstPairP1.terrainCardIndex];
            placeCard(startGridX, startGridY, 1, firstPairP1.unit, firstTerrainDataP1);

            currentPlayer = 2; // Player 2 places next

            const gridDirections = [[1, 0], [-1, 0], [0, 1], [0, -1]]; // Right, Left, Down, Up

            while (playerUnits[1].length > 0 || playerUnits[2].length > 0) {
                let availablePositions = new Map();

                board.forEach(card => {
                    if (!card || !card.unit) return;
                    const { gridX, gridY } = card;
                    gridDirections.forEach(([dx, dy]) => {
                        const nx = gridX + dx;
                        const ny = gridY + dy;
                        const gridKey = `${nx}_${ny}`;
                        if (!placedPositions.has(gridKey)) {
                            availablePositions.set(gridKey, { gridX: nx, gridY: ny });
                        }
                    });
                });

                if (availablePositions.size === 0) {
                    logMessage("Error: No available positions. Setup failed."); break;
                }

                const posArray = Array.from(availablePositions.values());
                const pos = posArray[Math.floor(Math.random() * posArray.length)];

                if (playerUnits[currentPlayer].length > 0) {
                    const pair = playerUnits[currentPlayer].pop();
                    const terrainData = fixedTerrainCards[pair.terrainCardIndex];
                    // Basic validation during placement isn't strictly needed now,
                    // as units are hidden and terrain doesn't block placement itself.
                    placeCard(pos.gridX, pos.gridY, currentPlayer, pair.unit, terrainData);
                }

                currentPlayer = currentPlayer === 1 ? 2 : 1;
            }

            currentPlayer = 1; // Start game with Player 1
            logMessage("Game ready. Player 1's turn.");
            updateUI();
        }

        document.addEventListener("DOMContentLoaded", resetGame);
    </script>
</body>
</html>