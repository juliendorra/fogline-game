<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fogline, card-based micro-wargame</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 10px;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #game-area {
            position: relative;
            width: 100vw;
            margin-bottom: 20px auto;
            border: 0px solid #ccc;
            background-color: #e8e8e8;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #board {
            display: inline-grid;
            padding: 27.5px;
        }

        .card {
            width: 75px;
            /* Portrait width */
            height: 105px;
            /* Portrait height */
            border: 1px solid #333;
            border-radius: 5px;
            position: relative;
            /* Needed for absolute positioning of edges */
            cursor: default;
            /* Default cursor */
            background-color: #fff;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            /* Pushes stats down */
            align-items: center;
            padding: 5px;
            box-sizing: border-box;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            margin: 2.5px;
            /* Space between cards */
            overflow: hidden;
            /* Hide overflowing edge content if any */
        }

        .card.selected {
            border: 2px solid gold;
            box-shadow: 0 0 10px gold;
        }

        .card.hidden {
            background-color: #888;
            /* Grey for hidden */
            color: #ccc;
        }

        .card.hidden .unit-name,
        .card.hidden .stats {
            /* Keep terrain edges visible */
            visibility: hidden;
        }

        .unit-name {
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            margin-top: 5px;
            z-index: 1;
            /* Above terrain edges */
        }

        .stats {
            font-size: 12px;
            text-align: center;
            width: 100%;
            display: flex;
            justify-content: space-around;
            margin-bottom: 5px;
            z-index: 1;
            /* Above terrain edges */
        }

        .stats span {
            display: inline-block;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .attack {
            background-color: #ffcccb;
            border: 1px solid #f08080;
        }

        .defense {
            background-color: #add8e6;
            border: 1px solid #87ceeb;
        }

        /* --- Cursor and Hover based on Action State --- */
        .selectable-initial {
            cursor: pointer;
        }

        .selectable-move {
            cursor: pointer;
        }

        .selectable-attack {
            cursor: crosshair;
        }

        .not-selectable {
            cursor: not-allowed;
        }

        .selectable-initial:hover,
        .selectable-move:hover,
        .selectable-attack:hover {
            transform: translateY(-3px);
            box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.3);
        }

        /* --- Terrain Edge Display --- */
        .terrain-edges {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Don't interfere with clicks */
            z-index: 0;
            /* Behind unit info */
        }

        .terrain-edge {
            position: absolute;
            font-size: 18px;
            /* Emoji size */
            line-height: 1;
            opacity: 0.8;
            /* Slightly faded */
        }

        .edge-top {
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
        }

        .edge-right {
            top: 50%;
            right: 2px;
            transform: translateY(-50%);
        }

        .edge-bottom {
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
        }

        .edge-left {
            top: 50%;
            left: 2px;
            transform: translateY(-50%);
        }

        /* Removed terrain background hints */

        .player1 {
            border-left: 5px solid #4a90e2;
        }

        .player2 {
            border-left: 5px solid #e94e77;
        }

        #info,
        #controls {
            margin-top: 15px;
            margin-bottom: 15px;
            text-align: center;
            width: 100%;
        }

        #info span {
            margin: 0 15px;
            font-weight: bold;
        }

        .player1-text {
            color: #4a90e2;
        }

        .player2-text {
            color: #e94e77;
        }

        button {
            padding: 8px 15px;
            font-size: 14px;
            cursor: pointer;
            background-color: #5cb85c;
            color: white;
            border: none;
            border-radius: 4px;
            margin: 5px;
        }

        button:hover {
            background-color: #4cae4c;
        }

        #defeated-units {
            margin-top: 20px;
            padding: 10px;
            border: 1px dashed #aaa;
            min-height: 120px;
            width: 90%;
            max-width: 1000px;
            background-color: #f8f8f8;
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            gap: 5px;
        }

        #defeated-units h4 {
            width: 100%;
            text-align: center;
            margin: 0 0 10px 0;
            color: #555;
        }

        .defeated-card {
            width: 60px;
            height: 90px;
            border: 1px solid #666;
            border-radius: 3px;
            background-color: #ccc;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 3px;
            box-sizing: border-box;
            font-size: 10px;
            position: relative;
            /* For edges */
        }

        .defeated-card .unit-name {
            font-size: 11px;
            font-weight: bold;
            margin-top: 3px;
            z-index: 1;
        }

        .defeated-card .stats {
            font-size: 9px;
            margin-bottom: 3px;
            z-index: 1;
        }

        /* Defeated cards also show edges */
        .defeated-card .terrain-edges {
            visibility: visible !important;
        }

        /* Override hidden */
        .defeated-card .terrain-edge {
            font-size: 12px;
            opacity: 0.6;
        }

        .defeated-card .edge-top {
            top: 1px;
        }

        .defeated-card .edge-right {
            right: 1px;
        }

        .defeated-card .edge-bottom {
            bottom: 1px;
        }

        .defeated-card .edge-left {
            left: 1px;
        }

        .defeated-card.player1 {
            border-left: 3px solid #4a90e2;
        }

        .defeated-card.player2 {
            border-left: 3px solid #e94e77;
        }

        /* --- Memo Pad Styles --- */
        #memo-popover {
            position: fixed;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 220px; /* Adjust width as needed */
            max-height: 80vh; /* Limit height */
            overflow-y: auto; /* Add scroll if content overflows */
            background-color: #fdfdfd;
            border: 1px solid #aaa;
            border-radius: 8px;
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.3);
            padding: 15px;
            z-index: 100; /* Ensure it's above other elements */
            display: none; /* Hidden by default */
            font-size: 12px;
        }

        #memo-popover h5 {
            margin-top: 0;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        #memo-popover ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #memo-popover li {
            margin-bottom: 8px;
            padding: 5px;
            border: 1px solid #eee;
            border-radius: 4px;
            background-color: #fff;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
         #memo-popover .memo-unit {
            font-weight: bold;
            flex-basis: 45%; /* Adjust as needed */
            text-align: left;
         }
         #memo-popover .memo-terrain {
            flex-basis: 50%; /* Adjust as needed */
            text-align: left; /* Align terrain block to left */
            font-size: 14px; /* Slightly larger emojis */
            display: grid; /* Use grid for spatial layout */
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 0px; /* Adjust gap as needed */
            width: 40px; /* Fixed width for the grid */
            height: 40px; /* Fixed height for the grid */
            place-items: center; /* Center emojis in grid cells */
            margin-right: 10px; /* Space between terrain and unit */
         }
         #memo-popover .memo-terrain .memo-edge-top { grid-column: 1 / 3; grid-row: 1; }
         #memo-popover .memo-terrain .memo-edge-right { grid-column: 2; grid-row: 1 / 3; align-self: center; }
         #memo-popover .memo-terrain .memo-edge-bottom { grid-column: 1 / 3; grid-row: 2; }
         #memo-popover .memo-terrain .memo-edge-left { grid-column: 1; grid-row: 1 / 3; align-self: center; }

         #memo-popover .memo-unit {
            font-weight: bold;
            flex-basis: 50%; /* Adjust as needed */
            text-align: right; /* Align unit name to right */
         }


        #memo-toggle-button {
             /* background-color removed, will be set dynamically */
             color: white; /* Keep text white */
             border: none; /* Assuming it should look like other buttons */
             padding: 8px 15px; /* Match other buttons */
             font-size: 14px; /* Match other buttons */
             border-radius: 4px; /* Match other buttons */
             margin: 5px; /* Match other buttons */
             cursor: pointer; /* Ensure cursor is pointer */
             transition: background-color 0.2s ease; /* Add transition */
        }
        #memo-toggle-button:hover {
             /* Hover effect can be slightly darker version of player color,
                or a generic effect like slight brightness change.
                Let's use filter for a simple darken effect. */
             filter: brightness(90%);
        }

        /* --- Placement Phase UI --- */
        #placement-controls {
            margin-top: 10px;
            margin-bottom: 10px;
            padding: 15px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            width: 90%;
            max-width: 1000px;
            text-align: center;
        }
        #placement-controls h4 {
            margin-top: 0;
            margin-bottom: 10px;
        }
        .placement-area {
            display: flex;
            justify-content: space-around;
            margin-bottom: 10px;
        }
        .placement-list {
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #fff;
            border-radius: 5px;
            max-height: 150px;
            overflow-y: auto;
            min-width: 200px;
        }
        .placement-list h5 {
            margin: 0 0 5px 0;
            text-align: center;
            font-size: 14px;
        }
        .placement-list ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .placement-list li {
            padding: 5px;
            margin-bottom: 3px;
            border: 1px solid #eee;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            display: flex; /* Use flex for alignment */
            align-items: center; /* Center items vertically */
            justify-content: space-between; /* Space out content */
        }
        .placement-list li:hover {
            background-color: #eef;
        }
        .placement-list li.selected-for-placement {
            background-color: #bbf;
            font-weight: bold;
        }
        .placement-terrain-preview {
            font-size: 14px; /* Emoji size */
            display: inline-grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 0px;
            width: 30px; /* Fixed width */
            height: 30px; /* Fixed height */
            place-items: center;
            margin-right: 8px; /* Space between preview and index */
        }
        .placement-terrain-preview .pt-top { grid-column: 1 / 3; grid-row: 1; }
        .placement-terrain-preview .pt-right { grid-column: 2; grid-row: 1 / 3; align-self: center; }
        .placement-terrain-preview .pt-bottom { grid-column: 1 / 3; grid-row: 2; }
        .placement-terrain-preview .pt-left { grid-column: 1; grid-row: 1 / 3; align-self: center; }

        /* --- Placeholder for Placement --- */
        .placement-placeholder {
            width: 75px;
            height: 105px;
            border: 2px dashed #aaa; /* Dashed border */
            border-radius: 5px;
            background-color: rgba(200, 200, 200, 0.2); /* Slightly transparent background */
            margin: 2.5px; /* Match card margin */
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            color: #aaa;
            cursor: copy; /* Indicate placement action */
            grid-column: var(--grid-x); /* Use CSS variables for position */
            grid-row: var(--grid-y);
        }
        .placement-placeholder:hover {
            background-color: rgba(180, 180, 180, 0.4);
            border-color: #888;
        }


    </style>
</head>

<body>
    <h2 style="text-align:center;">Fogline, card-based micro-wargame</h2>

    <!-- Memo Pad Popover -->
    <div id="memo-popover">
        <!-- Content generated by JS -->
    </div>

    <div id="info">Loading...</div>

    <!-- Placement Phase Controls (hidden initially) -->
    <div id="placement-controls" style="display: none;">
        <h4 id="placement-title">Placement Phase</h4>
        <div class="placement-area">
            <div class="placement-list">
                <h5>Available Units</h5>
                <ul id="available-units-list"></ul>
            </div>
            <div class="placement-list">
                <h5>Available Terrains</h5>
                <ul id="available-terrains-list"></ul>
            </div>
        </div>
        <p id="placement-instructions">Select one unit and one terrain, then click an empty, valid spot on the board.</p>
    </div>

    <div id="game-area">
        <div id="board"></div>
    </div>

    <div id="controls">
        <button onclick="resetGame()">Reset Game</button>
        <button id="memo-toggle-button" onclick="toggleMemoPad()">Show Memo Pad</button>
        <span id="message-log" style="margin-left: 20px; color: #333; font-style: italic;"></span>
    </div>

    <div id="defeated-units">
        <h4>Defeated Units</h4>
    </div>

    <script>
        let board = []; // Stores card objects { id, unit, terrain: {top, right, bottom, left}, hidden, owner, gridX, gridY, element }
        let currentPlayer = 1;
        let playerUnits = {}; // { 1: [{unit, terrainCardIndex}, ...], 2: [...] }
        let placedPositions = new Set(); // Store "x_y" strings
        let selectedCardIndex = null; // Index in the board array for gameplay phase
        let defeatedUnits = []; // Stores { unit, terrain: {top, right, bottom, left}, owner } of defeated units
        let nextCardId = 0; // Unique ID for each card
        let initialPlayerPairings = { 1: [], 2: [] }; // To store initial setup for memo pad
        let isResolvingAttack = false; // Flag to prevent clicks during attack resolution

        // --- Game State & Placement Variables ---
        let gameState = 'PLACEMENT'; // 'PLACEMENT' or 'GAMEPLAY'
        let playerAvailableUnits = { 1: [], 2: [] };
        let playerAvailableTerrains = { 1: [], 2: [] }; // Stores terrain indices
        let selectedUnitForPlacement = null; // Name of the selected unit
        let selectedUnitIndexForPlacement = null; // Index of the selected unit in the available list
        let selectedTerrainIndexForPlacement = null;
        let placedCardCount = 0;
        const TOTAL_CARDS_TO_PLACE = 16;

        const START_GRID_COORD = 10; // Start placing cards around grid cell 10,10
        // Terrain Types & Emojis
        const TERRAIN_TYPES = {
            PLAINS: 'Plains',
            FOREST: 'Forest',
            MOUNTAIN: 'Mountain'
        };
        const TERRAIN_EMOJIS = {
            [TERRAIN_TYPES.PLAINS]: 'üèûÔ∏è',
            [TERRAIN_TYPES.FOREST]: 'üå≤',
            [TERRAIN_TYPES.MOUNTAIN]: '‚õ∞Ô∏è'
        };

        // Unit Stats (Movement based on terrain *type*)
        const unitStats = {
            'Mobile Command': { attack: 1, defense: 2, quantity: 1, canTraverse: [TERRAIN_TYPES.PLAINS] },
            'Tank': { attack: 4, defense: 4, quantity: 2, canTraverse: [TERRAIN_TYPES.PLAINS] },
            'Infantry': { attack: 3, defense: 3, quantity: 3, canTraverse: [TERRAIN_TYPES.PLAINS, TERRAIN_TYPES.FOREST, TERRAIN_TYPES.MOUNTAIN] },
            'Artillery': { attack: 5, defense: 1, quantity: 1, canTraverse: [TERRAIN_TYPES.PLAINS] },
            'Special Ops': { attack: 3, defense: 1, quantity: 1, canTraverse: [TERRAIN_TYPES.PLAINS, TERRAIN_TYPES.FOREST, TERRAIN_TYPES.MOUNTAIN] }
        };

        // Terrain Rules (Defense bonus based on type)
        const terrainRules = {
            [TERRAIN_TYPES.PLAINS]: { defenseBonus: 0 },
            [TERRAIN_TYPES.FOREST]: { defenseBonus: 1 },
            [TERRAIN_TYPES.MOUNTAIN]: { defenseBonus: 0 }
        };

        // The 8 Fixed Terrain Cards (Top, Right, Bottom, Left)
        const fixedTerrainCards = [
            { top: TERRAIN_TYPES.PLAINS, right: TERRAIN_TYPES.FOREST, bottom: TERRAIN_TYPES.PLAINS, left: TERRAIN_TYPES.FOREST },
            { top: TERRAIN_TYPES.PLAINS, right: TERRAIN_TYPES.MOUNTAIN, bottom: TERRAIN_TYPES.PLAINS, left: TERRAIN_TYPES.MOUNTAIN },
            { top: TERRAIN_TYPES.FOREST, right: TERRAIN_TYPES.PLAINS, bottom: TERRAIN_TYPES.FOREST, left: TERRAIN_TYPES.PLAINS },
            { top: TERRAIN_TYPES.MOUNTAIN, right: TERRAIN_TYPES.PLAINS, bottom: TERRAIN_TYPES.MOUNTAIN, left: TERRAIN_TYPES.PLAINS },
            { top: TERRAIN_TYPES.FOREST, right: TERRAIN_TYPES.FOREST, bottom: TERRAIN_TYPES.PLAINS, left: TERRAIN_TYPES.MOUNTAIN },
            { top: TERRAIN_TYPES.MOUNTAIN, right: TERRAIN_TYPES.MOUNTAIN, bottom: TERRAIN_TYPES.PLAINS, left: TERRAIN_TYPES.FOREST },
            { top: TERRAIN_TYPES.FOREST, right: TERRAIN_TYPES.MOUNTAIN, bottom: TERRAIN_TYPES.FOREST, left: TERRAIN_TYPES.PLAINS },
            { top: TERRAIN_TYPES.MOUNTAIN, right: TERRAIN_TYPES.FOREST, bottom: TERRAIN_TYPES.MOUNTAIN, left: TERRAIN_TYPES.PLAINS }
        ];

        function getUnitList() {
            const units = [];
            for (const type in unitStats) {
                for (let i = 0; i < unitStats[type].quantity; i++) {
                    units.push(type);
                }
            }
            return units; // Should be 8 units total
        }

        // Fisher-Yates Shuffle
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Place card with 4-sided terrain
        function placeCard(gridX, gridY, owner, unit, terrainData) {
            const cardId = nextCardId++;
            const card = { id: cardId, unit, terrain: terrainData, hidden: true, owner, gridX, gridY, element: null };
            board.push(card);
            const gridKey = `${gridX}_${gridY}`;
            placedPositions.add(gridKey);

            const boardDiv = document.getElementById('board');
            const cardDiv = document.createElement('div');
            // Remove terrain-X class, add player class
            cardDiv.className = `card hidden player${owner}`;
            cardDiv.style.gridColumn = gridX;
            cardDiv.style.gridRow = gridY;
            cardDiv.dataset.id = cardId;
            cardDiv.onclick = () => handleCardClick(cardId);

            // Add structure for content including terrain edges
            cardDiv.innerHTML = `
                <div class="terrain-edges">
                    <span class="terrain-edge edge-top">${TERRAIN_EMOJIS[terrainData.top]}</span>
                    <span class="terrain-edge edge-right">${TERRAIN_EMOJIS[terrainData.right]}</span>
                    <span class="terrain-edge edge-bottom">${TERRAIN_EMOJIS[terrainData.bottom]}</span>
                    <span class="terrain-edge edge-left">${TERRAIN_EMOJIS[terrainData.left]}</span>
                </div>
                <div class="unit-name">${unit || '?'}</div>
                <div class="stats">
                    <span class="attack">A: ?</span>
                    <span class="defense">D: ?</span>
                </div>
                <!-- Removed single terrain-name div -->
            `;

            boardDiv.appendChild(cardDiv);
            card.element = cardDiv;
            return card;
        }

        function findCardIndexById(id) {
            return board.findIndex(card => card && card.id === id);
        }
        function findCardById(id) {
            return board.find(card => card && card.id === id);
        }
        function findCardByGrid(gridX, gridY) {
            return board.find(card => card && card.gridX === gridX && card.gridY === gridY);
        }

        // Helper to get direction and opposite direction between adjacent cards
        function getDirectionInfo(card1, card2) {
            if (!card1 || !card2) return null;
            const dx = card2.gridX - card1.gridX;
            const dy = card2.gridY - card1.gridY;

            if (dx === 1 && dy === 0) return { direction: 'right', opposite: 'left' };
            if (dx === -1 && dy === 0) return { direction: 'left', opposite: 'right' };
            if (dx === 0 && dy === 1) return { direction: 'bottom', opposite: 'top' }; // Grid Y increases downwards
            if (dx === 0 && dy === -1) return { direction: 'top', opposite: 'bottom' }; // Grid Y decreases upwards
            return null; // Not adjacent or same card
        }

        // Helper to check if a unit can traverse a specific terrain type
        function canUnitTraverse(unitName, terrainType) {
            if (!unitName || !terrainType) return false;
            const stats = unitStats[unitName];
            return stats && stats.canTraverse.includes(terrainType);
        }


        function handleCardClick(cardId) {
            // This function handles clicks on CARDS during the GAMEPLAY phase
            if (gameState !== 'GAMEPLAY' || isResolvingAttack) return;

            const clickedCardIndex = findCardIndexById(cardId);
            if (clickedCardIndex === -1) return;
            const clickedCard = board[clickedCardIndex];

            logMessage(""); // Clear previous message

            if (selectedCardIndex === null) {
                // --- Selecting a unit ---
                if (clickedCard.owner !== currentPlayer) {
                    logMessage("Cannot select opponent's card."); return;
                }
                if (!clickedCard.unit) {
                    logMessage("Cannot select an empty space."); return;
                }

                if (clickedCard.hidden) {
                    clickedCard.hidden = false;
                    logMessage(`Player ${currentPlayer} revealed ${clickedCard.unit}.`);
                }

                selectedCardIndex = clickedCardIndex;
                board.forEach(c => c.element?.classList.remove('selected'));
                clickedCard.element.classList.add('selected');

            } else {
                // --- Target selected ---
                const attackerCard = board[selectedCardIndex];

                if (clickedCardIndex === selectedCardIndex) { // Deselecting
                    selectedCardIndex = null;
                    attackerCard.element.classList.remove('selected');
                    logMessage("Card deselected.");
                    updateUI();
                    return;
                }

                const directionInfo = getDirectionInfo(attackerCard, clickedCard);
                if (!directionInfo) {
                    logMessage("Target is not adjacent."); return;
                }

                // --- Check Movement Legality ---
                // Unit must be able to traverse the terrain on the *destination* card's edge
                // that faces the *origin* card.
                const entryTerrainType = clickedCard.terrain[directionInfo.opposite];
                if (!canUnitTraverse(attackerCard.unit, entryTerrainType)) {
                    logMessage(`${attackerCard.unit} cannot enter via ${entryTerrainType} (${directionInfo.opposite} edge of target).`);
                    return;
                }

                // --- Process Action: Move or Attack ---
                if (clickedCard.owner === currentPlayer) {
                    logMessage("Cannot move/attack your own unit."); return;
                }

                if (!clickedCard.unit) {
                    // --- Moving to empty adjacent tile ---
                    logMessage(`Player ${currentPlayer} moved ${attackerCard.unit} via ${entryTerrainType}.`);

                    // Update board state - Data moves
                    clickedCard.unit = attackerCard.unit;
                    clickedCard.owner = attackerCard.owner;
                    clickedCard.hidden = false; // Moved unit is revealed

                    attackerCard.unit = null;
                    attackerCard.owner = null;
                    attackerCard.hidden = true; // Previous spot becomes empty/hidden

                    // Grid positions remain, data swapped. placedPositions doesn't need update here.

                    selectedCardIndex = null;
                    currentPlayer = currentPlayer === 1 ? 2 : 1;
                    isResolvingAttack = false;

                } else {
                    // --- Attacking an enemy unit ---
                    logMessage(`Player ${currentPlayer}'s ${attackerCard.unit} attacks ${clickedCard.unit}...`);
                    isResolvingAttack = true;

                    if (clickedCard.hidden) {
                        clickedCard.hidden = false;
                        logMessage(`Revealed defender: ${clickedCard.unit}.`);
                        updateUI(); // Show revealed defender
                    }

                    setTimeout(() => {
                        resolveAttack(selectedCardIndex, clickedCardIndex);
                        isResolvingAttack = false; // Unlock after resolution
                    }, 1500);
                }
                // Update UI after move or before attack resolution starts
                updateUI();
            }
            // Update UI if only selecting/deselecting
            if (!isResolvingAttack) updateUI();
        }

        function resolveAttack(attackerIndex, defenderIndex) {
            const attackerCard = board[attackerIndex];
            const defenderCard = board[defenderIndex];

            if (!attackerCard || !attackerCard.unit || !defenderCard || !defenderCard.unit) {
                logMessage("Attack cancelled - unit missing.");
                isResolvingAttack = false;
                selectedCardIndex = null;
                updateUI();
                return;
            }

            const attackerStats = unitStats[attackerCard.unit];
            const defenderStats = unitStats[defenderCard.unit];

            // Determine defense bonus based on the defender's edge facing the attacker
            const directionInfo = getDirectionInfo(attackerCard, defenderCard);
            const defenseEdgeTerrain = defenderCard.terrain[directionInfo.opposite];
            const terrainBonus = terrainRules[defenseEdgeTerrain]?.defenseBonus || 0;

            const attackValue = attackerStats.attack;
            const defenseValue = defenderStats.defense + terrainBonus;

            logMessage(`${attackerCard.unit} (A:${attackValue}) vs ${defenderCard.unit} (D:${defenderStats.defense} + ${terrainBonus} Bonus = ${defenseValue}) attacking via ${defenseEdgeTerrain}`);

            let winner, loser;
            let attackerWins = attackValue > defenseValue; // Defender wins ties

            if (attackerWins) {
                winner = attackerCard;
                loser = defenderCard;
                logMessage(`Attacker wins! ${winner.unit} defeats ${loser.unit}.`);

                defeatedUnits.push({ unit: loser.unit, terrain: loser.terrain, owner: loser.owner });

                // Update board: Attacker data moves to defender's card object
                defenderCard.unit = attackerCard.unit;
                defenderCard.owner = attackerCard.owner;
                defenderCard.hidden = false; // Winner is revealed

                // Clear attacker's original card object data
                attackerCard.unit = null;
                attackerCard.owner = null;
                attackerCard.hidden = true; // Visually empty

            } else { // Defender wins
                winner = defenderCard;
                loser = attackerCard;
                logMessage(`Defender wins! ${winner.unit} defeats ${loser.unit}.`);

                defeatedUnits.push({ unit: loser.unit, terrain: loser.terrain, owner: loser.owner });

                // Update board: Defender holds, clear attacker's card object data
                attackerCard.unit = null;
                attackerCard.owner = null;
                attackerCard.hidden = true; // Visually empty

                // Defender remains revealed
                defenderCard.hidden = false;
            }

            // Check for win conditions
            const commandUnit = 'Mobile Command';
            const remainingUnitsP1 = board.filter(c => c && c.owner === 1 && c.unit && c.unit !== commandUnit).length;
            const remainingUnitsP2 = board.filter(c => c && c.owner === 2 && c.unit && c.unit !== commandUnit).length;
            const commandP1 = board.find(c => c && c.unit === commandUnit && c.owner === 1);
            const commandP2 = board.find(c => c && c.unit === commandUnit && c.owner === 2);

            let gameOver = false;
            if (!commandP2) {
                logMessage(`Player 1 wins by capturing the Mobile Command!`); gameOver = true;
            } else if (!commandP1) {
                logMessage(`Player 2 wins by capturing the Mobile Command!`); gameOver = true;
            } else if (remainingUnitsP2 === 0 && commandP2) { // Check command still exists
                logMessage(`Player 1 wins by eliminating all other movable units!`); gameOver = true;
            } else if (remainingUnitsP1 === 0 && commandP1) { // Check command still exists
                logMessage(`Player 2 wins by eliminating all other movable units!`); gameOver = true;
            }

            selectedCardIndex = null;
            if (!gameOver) {
                currentPlayer = currentPlayer === 1 ? 2 : 1;
            } else {
                isResolvingAttack = true; // Keep locked if game over
            }

            updateUI();
        }

        // isAdjacent check remains the same (based on grid)
        function isAdjacent(card1, card2) {
            if (!card1 || !card2) return false;
            const dx = Math.abs(card1.gridX - card2.gridX);
            const dy = Math.abs(card1.gridY - card2.gridY);
            return (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
        }

        function updateUI() {
            const placementControlsDiv = document.getElementById('placement-controls');
            const infoDiv = document.getElementById('info');
            const memoButton = document.getElementById('memo-toggle-button');
            const boardDiv = document.getElementById('board');

            // --- State-Specific UI Updates ---

            // --- Remove Old Placeholders ---
            // Do this regardless of state to clean up when switching from PLACEMENT to GAMEPLAY
            boardDiv.querySelectorAll('.placement-placeholder').forEach(el => el.remove());

            if (gameState === 'PLACEMENT') {
                placementControlsDiv.style.display = 'block';
                infoDiv.style.display = 'none'; // Hide regular info during placement
                memoButton.style.display = 'none'; // Hide memo button during placement
                boardDiv.style.cursor = 'copy'; // Indicate placement action

                // --- Calculate and Render Placement Placeholders ---
                const potentialSpots = new Set();
                if (placedPositions.size === 0) {
                    // If board is empty, offer the starting spot
                    potentialSpots.add(`${START_GRID_COORD}_${START_GRID_COORD}`);
                } else {
                    placedPositions.forEach(posKey => {
                        const [x, y] = posKey.split('_').map(Number);
                        const neighbors = [
                            `${x + 1}_${y}`, `${x - 1}_${y}`,
                            `${x}_${y + 1}`, `${x}_${y - 1}`
                        ];
                        neighbors.forEach(neighborKey => {
                            if (!placedPositions.has(neighborKey)) {
                                potentialSpots.add(neighborKey);
                            }
                        });
                    });
                }

                potentialSpots.forEach(spotKey => {
                    const [x, y] = spotKey.split('_').map(Number);
                    const placeholder = document.createElement('div');
                    placeholder.className = 'placement-placeholder';
                    placeholder.style.setProperty('--grid-x', x); // Use CSS variables
                    placeholder.style.setProperty('--grid-y', y);
                    // Optional: Add a visual cue like a plus sign
                    // placeholder.textContent = '+';
                    // Add data attributes to potentially simplify click handling later
                    placeholder.dataset.gridX = x;
                    placeholder.dataset.gridY = y;
                    boardDiv.appendChild(placeholder);
                });
                // --- End Placeholder Rendering ---


                // Update placement title and instructions
                document.getElementById('placement-title').textContent = `Placement Phase - Player ${currentPlayer}'s Turn`;
                document.getElementById('placement-instructions').textContent = `Select one unit and one terrain, then click an empty, valid spot on the board. (${placedCardCount}/${TOTAL_CARDS_TO_PLACE} placed)`;

                // Populate available units list
                const unitsList = document.getElementById('available-units-list');
                unitsList.innerHTML = '';
                playerAvailableUnits[currentPlayer].forEach((unitName, index) => { // Add index here
                    const li = document.createElement('li');
                    li.textContent = unitName;
                    // Pass both index and name to the selection function
                    li.onclick = () => selectUnitForPlacement(index, unitName);
                    // Highlight based on the stored index
                    if (index === selectedUnitIndexForPlacement) {
                        li.classList.add('selected-for-placement');
                    }
                    unitsList.appendChild(li);
                });

                // Populate available terrains list
                const terrainsList = document.getElementById('available-terrains-list');
                terrainsList.innerHTML = '';
                playerAvailableTerrains[currentPlayer].forEach(terrainIndex => {
                    const terrainData = fixedTerrainCards[terrainIndex];
                    const li = document.createElement('li');
                    li.onclick = () => selectTerrainForPlacement(terrainIndex);
                    if (terrainIndex === selectedTerrainIndexForPlacement) {
                        li.classList.add('selected-for-placement');
                    }
                    // Add terrain preview
                    const previewSpan = document.createElement('span');
                    previewSpan.className = 'placement-terrain-preview';
                    previewSpan.innerHTML = `
                        <span class="pt-top">${TERRAIN_EMOJIS[terrainData.top]}</span>
                        <span class="pt-right">${TERRAIN_EMOJIS[terrainData.right]}</span>
                        <span class="pt-bottom">${TERRAIN_EMOJIS[terrainData.bottom]}</span>
                        <span class="pt-left">${TERRAIN_EMOJIS[terrainData.left]}</span>
                    `;
                    li.appendChild(previewSpan);
                    // Add text identifier (optional, could be index or a name)
                    // li.appendChild(document.createTextNode(` Card #${terrainIndex + 1}`)); // Example text
                    terrainsList.appendChild(li);
                });

            } else { // GAMEPLAY state
                placementControlsDiv.style.display = 'none';
                infoDiv.style.display = 'block'; // Show regular info
                memoButton.style.display = 'inline-block'; // Show memo button
                boardDiv.style.cursor = 'default'; // Reset cursor for gameplay

                // Update Info Bar
                const p1Units = board.filter(c => c && c.owner === 1 && c.unit).length;
                const p2Units = board.filter(c => c && c.owner === 2 && c.unit).length;
                infoDiv.innerHTML = `
                    <span class="player1-text">Player 1 Units: ${p1Units}</span> |
                    <span class="${currentPlayer === 1 ? 'player1-text' : 'player2-text'}">Current Turn: Player ${currentPlayer}</span> |
                    <span class="player2-text">Player 2 Units: ${p2Units}</span>
                 `;

                // Update Memo Toggle Button Text and Color
                if (memoButton) {
                    memoButton.textContent = `Player ${currentPlayer} Memo`;
                    memoButton.style.backgroundColor = currentPlayer === 1 ? '#4a90e2' : '#e94e77';
                }
                // If memo pad is open, update its content for the current player
                const memoPopover = document.getElementById('memo-popover');
                if (memoPopover && window.getComputedStyle(memoPopover).display !== 'none') {
                    displayMemoPadContent(currentPlayer);
                }
            }

            // --- Common UI Updates (Cards, Defeated Area) ---
            const attackerCard = selectedCardIndex !== null ? board[selectedCardIndex] : null;

            // --- Update Card Elements ---
            board.forEach((card, i) => {
                if (!card || !card.element) return; // Skip removed/missing

                const div = card.element;
                // Reset base classes and remove selectable states
                div.className = `card player${card.owner || 0}`; // Base classes first
                div.classList.remove('selectable-initial', 'selectable-move', 'selectable-attack', 'not-selectable', 'selected', 'hidden'); // Clear states

                if (card.hidden) div.classList.add('hidden');
                if (i === selectedCardIndex) div.classList.add('selected');

                // --- Determine Selectable State ---
                if (selectedCardIndex === null) { // Selecting initial unit
                    if (card.owner === currentPlayer && card.unit) {
                        div.classList.add('selectable-initial');
                    } else {
                        div.classList.add('not-selectable');
                    }
                } else { // Unit selected, selecting target
                    if (i === selectedCardIndex) {
                        div.classList.add('not-selectable'); // Can't target self
                    } else {
                        const directionInfo = getDirectionInfo(attackerCard, card);
                        if (directionInfo) { // Is adjacent
                            const entryTerrainType = card.terrain[directionInfo.opposite];
                            if (canUnitTraverse(attackerCard.unit, entryTerrainType)) {
                                if (card.unit === null) { // Empty, valid square
                                    div.classList.add('selectable-move');
                                } else if (card.owner !== currentPlayer) { // Enemy unit
                                    div.classList.add('selectable-attack');
                                } else { // Own unit
                                    div.classList.add('not-selectable');
                                }
                            } else { // Invalid terrain edge
                                div.classList.add('not-selectable');
                            }
                        } else { // Not adjacent
                            div.classList.add('not-selectable');
                        }
                    }
                }
                // --- End Selectable State ---

                // Update Content (Unit Name, Stats, Terrain Edges)
                const unitNameDiv = div.querySelector('.unit-name');
                const statsDiv = div.querySelector('.stats');
                const attackSpan = statsDiv.querySelector('.attack');
                const defenseSpan = statsDiv.querySelector('.defense');
                const terrainEdgesDiv = div.querySelector('.terrain-edges');
                const edgeSpans = {
                    top: terrainEdgesDiv.querySelector('.edge-top'),
                    right: terrainEdgesDiv.querySelector('.edge-right'),
                    bottom: terrainEdgesDiv.querySelector('.edge-bottom'),
                    left: terrainEdgesDiv.querySelector('.edge-left'),
                };

                // Update terrain emojis (always visible unless card.hidden)
                edgeSpans.top.textContent = TERRAIN_EMOJIS[card.terrain.top];
                edgeSpans.right.textContent = TERRAIN_EMOJIS[card.terrain.right];
                edgeSpans.bottom.textContent = TERRAIN_EMOJIS[card.terrain.bottom];
                edgeSpans.left.textContent = TERRAIN_EMOJIS[card.terrain.left];

                if (card.unit && !card.hidden) {
                    unitNameDiv.textContent = card.unit;
                    const stats = unitStats[card.unit];
                    attackSpan.textContent = `A: ${stats.attack}`;
                    defenseSpan.textContent = `D: ${stats.defense}`;
                    unitNameDiv.style.visibility = 'visible';
                    statsDiv.style.visibility = 'visible';
                    terrainEdgesDiv.style.visibility = 'visible'; // Ensure edges are visible
                } else if (card.unit && card.hidden) {
                    unitNameDiv.textContent = '?';
                    attackSpan.textContent = `A: ?`;
                    defenseSpan.textContent = `D: ?`;
                    unitNameDiv.style.visibility = 'hidden';
                    statsDiv.style.visibility = 'hidden';
                    terrainEdgesDiv.style.visibility = 'visible'; // KEEP edges visible
                } else { // Empty spot
                    unitNameDiv.textContent = '';
                    attackSpan.textContent = `A: -`;
                    defenseSpan.textContent = `D: -`;
                    unitNameDiv.style.visibility = 'hidden';
                    statsDiv.style.visibility = 'hidden';
                    terrainEdgesDiv.style.visibility = 'visible'; // Show terrain even if empty
                    div.classList.add('hidden'); // Make empty spots look like fog
                }
            });

            // Update Defeated Units Area
            const defeatedDiv = document.getElementById('defeated-units');
            defeatedDiv.innerHTML = '<h4>Defeated Units</h4>'; // Clear previous
            defeatedUnits.forEach(defeated => {
                const defeatedCardDiv = document.createElement('div');
                defeatedCardDiv.className = `defeated-card player${defeated.owner}`;
                const stats = unitStats[defeated.unit];
                const attack = stats ? stats.attack : '?';
                const defense = stats ? stats.defense : '?';
                defeatedCardDiv.innerHTML = `
                    <div class="terrain-edges">
                       <span class="terrain-edge edge-top">${TERRAIN_EMOJIS[defeated.terrain.top]}</span>
                       <span class="terrain-edge edge-right">${TERRAIN_EMOJIS[defeated.terrain.right]}</span>
                       <span class="terrain-edge edge-bottom">${TERRAIN_EMOJIS[defeated.terrain.bottom]}</span>
                       <span class="terrain-edge edge-left">${TERRAIN_EMOJIS[defeated.terrain.left]}</span>
                    </div>
                    <div class="unit-name">${defeated.unit}</div>
                    <div class="stats">
                       <span class="attack">A:${attack}</span> <span class="defense">D:${defense}</span>
                    </div>
                    <!-- No single terrain name -->`;
                defeatedDiv.appendChild(defeatedCardDiv);
            });
        }

        function logMessage(msg) {
            document.getElementById('message-log').textContent = msg;
            console.log(msg);
        }

        function resetGame() {
            logMessage("Setting up new game...");
            // Reset Core Game State
            board = [];
            placedPositions.clear();
            selectedCardIndex = null; // Gameplay selection
            isResolvingAttack = false;
            defeatedUnits = [];
            nextCardId = 0;
            document.getElementById('board').innerHTML = '';
            document.getElementById('defeated-units').innerHTML = '<h4>Defeated Units</h4>';
            document.getElementById('memo-popover').style.display = 'none'; // Hide memo pad

            // Reset Placement State
            gameState = 'PLACEMENT';
            playerAvailableUnits = { 1: shuffle(getUnitList()), 2: shuffle(getUnitList()) };
            playerAvailableTerrains = { 1: shuffle([...Array(8).keys()]), 2: shuffle([...Array(8).keys()]) };
            selectedUnitForPlacement = null;
            selectedUnitIndexForPlacement = null; // Reset index as well
            selectedTerrainIndexForPlacement = null;
            placedCardCount = 0;

            // Store initial pairings for memo pad (deep copy needed)
             initialPlayerPairings = {
                 1: playerAvailableUnits[1].map((unit, i) => ({ unit: unit, terrain: fixedTerrainCards[playerAvailableTerrains[1][i]] })),
                 2: playerAvailableUnits[2].map((unit, i) => ({ unit: unit, terrain: fixedTerrainCards[playerAvailableTerrains[2][i]] }))
             };
             // Sort for consistent memo display
             initialPlayerPairings[1].sort((a, b) => a.unit.localeCompare(b.unit));
             initialPlayerPairings[2].sort((a, b) => a.unit.localeCompare(b.unit));


            currentPlayer = 1; // Player 1 starts placement
            logMessage("Placement phase. Player 1's turn.");

            // Add the board click listener for placement
            const boardDiv = document.getElementById('board');
            // Remove previous listener if any to avoid duplicates on reset
            boardDiv.removeEventListener('click', handleBoardClickForPlacement);
            boardDiv.addEventListener('click', handleBoardClickForPlacement);

            updateUI();
        }


        // --- Placement Phase Functions ---

        function selectUnitForPlacement(index, unitName) { // Accept index and name
            if (gameState !== 'PLACEMENT') return;
            selectedUnitIndexForPlacement = index; // Store the index
            selectedUnitForPlacement = unitName; // Store the name
            logMessage(`Selected Unit: ${unitName} (at index ${index})`);
            updateUI(); // Re-render to show selection highlight
        }

        function selectTerrainForPlacement(terrainIndex) {
            if (gameState !== 'PLACEMENT') return;
            selectedTerrainIndexForPlacement = terrainIndex;
            const terrainData = fixedTerrainCards[terrainIndex];
            logMessage(`Selected Terrain: [${TERRAIN_EMOJIS[terrainData.top]}, ${TERRAIN_EMOJIS[terrainData.right]}, ${TERRAIN_EMOJIS[terrainData.bottom]}, ${TERRAIN_EMOJIS[terrainData.left]}]`);
            updateUI(); // Re-render to show selection highlight
        }

        function handleBoardClickForPlacement(event) {
            if (gameState !== 'PLACEMENT') return;

            // Ensure a unit and terrain are selected
            if (selectedUnitForPlacement === null || selectedTerrainIndexForPlacement === null) {
                logMessage("Please select both a unit and a terrain card first.");
                return;
            }

            // Calculate grid coordinates from click position relative to the board
            const boardRect = event.currentTarget.getBoundingClientRect();
            // Estimate card size including margin/padding for grid calculation
            const cardWidthEstimate = 75 + 5; // card width + margin
            const cardHeightEstimate = 105 + 5; // card height + margin
            // Adjust click coordinates to be relative to the board's content area (including padding)
            const clickX = event.clientX - boardRect.left;
            const clickY = event.clientY - boardRect.top;

            // This calculation is approximate and might need adjustment based on how the grid grows.
            // Calculate grid cell based on click position relative to the board's content area
            // Note: This calculation assumes a relatively uniform grid expansion.
            // A more precise method might involve finding the min/max grid coords currently used.
            // Let's try a slightly simpler calculation assuming grid starts near 0,0 relative to padding edge.
            // We still use START_GRID_COORD as the logical center index.
            // We need the board's padding to offset correctly.
            const boardPadding = parseFloat(window.getComputedStyle(event.currentTarget).paddingLeft) || 0; // Assuming uniform padding, default to 0 if parsing fails

            const clickedGridX = Math.floor((clickX - boardPadding) / cardWidthEstimate) + START_GRID_COORD;
            const clickedGridY = Math.floor((clickY - boardPadding) / cardHeightEstimate) + START_GRID_COORD;

            // If the click target was a placeholder, use its data attributes for precision
            let targetGridX = clickedGridX;
            let targetGridY = clickedGridY;
            if (event.target.classList.contains('placement-placeholder')) {
                 targetGridX = parseInt(event.target.dataset.gridX, 10);
                 targetGridY = parseInt(event.target.dataset.gridY, 10);
                 logMessage(`Clicked placeholder at (${targetGridX}, ${targetGridY})`);
            }


            const gridKey = `${targetGridX}_${targetGridY}`;

            // --- Validate Placement Location ---
            // Check if the target spot is one of the valid potential spots
            const potentialSpots = new Set();
             if (placedPositions.size === 0) {
                 potentialSpots.add(`${START_GRID_COORD}_${START_GRID_COORD}`);
             } else {
                 placedPositions.forEach(posKey => {
                     const [x, y] = posKey.split('_').map(Number);
                     const neighbors = [
                         `${x + 1}_${y}`, `${x - 1}_${y}`,
                         `${x}_${y + 1}`, `${x}_${y - 1}`
                     ];
                     neighbors.forEach(neighborKey => {
                         if (!placedPositions.has(neighborKey)) {
                             potentialSpots.add(neighborKey);
                         }
                     });
                 });
             }

            if (!potentialSpots.has(gridKey)) {
                 logMessage("Invalid placement spot. Click on one of the dashed outlines.");
                 return;
            }

            // Spot is valid and unoccupied (implicit from being in potentialSpots)

            // --- Place the Card ---
            logMessage(`Player ${currentPlayer} placing ${selectedUnitForPlacement} on terrain #${selectedTerrainIndexForPlacement + 1} at (${targetGridX}, ${targetGridY}).`);
            const terrainData = fixedTerrainCards[selectedTerrainIndexForPlacement];
            placeCard(targetGridX, targetGridY, currentPlayer, selectedUnitForPlacement, terrainData);

            // Remove placed unit and terrain from available lists
            // Use the stored index to remove the unit directly
            if (selectedUnitIndexForPlacement !== null && selectedUnitIndexForPlacement < playerAvailableUnits[currentPlayer].length) {
                 playerAvailableUnits[currentPlayer].splice(selectedUnitIndexForPlacement, 1); // Remove 1 element at the stored index
            } else {
                 console.error("Error: Invalid selected unit index for removal."); // Should not happen if selection is working
            }

            // Terrain indices are unique, so filter is fine here
            playerAvailableTerrains[currentPlayer] = playerAvailableTerrains[currentPlayer].filter(tIdx => tIdx !== selectedTerrainIndexForPlacement);

            // Reset selections and increment count
            selectedUnitForPlacement = null;
            selectedUnitIndexForPlacement = null; // Reset the index
            selectedTerrainIndexForPlacement = null;
            placedCardCount++;

            // Check if placement phase is over
            if (placedCardCount >= TOTAL_CARDS_TO_PLACE) {
                gameState = 'GAMEPLAY';
                currentPlayer = 1; // Player 1 starts the gameplay phase
                logMessage("Placement complete! Player 1's turn to move or attack.");
                // Remove the board click listener for placement
                document.getElementById('board').removeEventListener('click', handleBoardClickForPlacement);
                document.getElementById('board').style.cursor = 'default'; // Reset cursor
            } else {
                // Switch to the other player for the next placement
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                logMessage(`Player ${currentPlayer}'s turn to place.`);
            }

            updateUI();
        }


        // --- Memo Pad Functions ---

        function displayMemoPadContent(player) {
            const memoPopover = document.getElementById('memo-popover');
            const originalPairings = initialPlayerPairings[player];
            if (!originalPairings || originalPairings.length === 0) {
                memoPopover.innerHTML = `<h5>Player ${player} Memo Pad</h5><p>No pairings data found.</p>`;
                return;
            }

            // Create a copy and sort it based on Left -> Top -> Right terrain edges
            const sortedPairings = [...originalPairings].sort((a, b) => {
                const leftCompare = a.terrain.left.localeCompare(b.terrain.left);
                if (leftCompare !== 0) return leftCompare;

                const topCompare = a.terrain.top.localeCompare(b.terrain.top);
                if (topCompare !== 0) return topCompare;

                return a.terrain.right.localeCompare(b.terrain.right);
            });


            let content = `<h5>Player ${player} Memo Pad</h5><ul>`;
            sortedPairings.forEach(pair => {
                // Arrange terrain emojis spatially within the memo-terrain span
                const terrainEmojis = `
                    <span class="memo-edge-top">${TERRAIN_EMOJIS[pair.terrain.top]}</span>
                    <span class="memo-edge-right">${TERRAIN_EMOJIS[pair.terrain.right]}</span>
                    <span class="memo-edge-bottom">${TERRAIN_EMOJIS[pair.terrain.bottom]}</span>
                    <span class="memo-edge-left">${TERRAIN_EMOJIS[pair.terrain.left]}</span>
                `;
                // Place terrain span first, then unit span
                content += `<li><span class="memo-terrain">${terrainEmojis}</span><span class="memo-unit">${pair.unit}</span></li>`;
            });
            content += `</ul>`;
            memoPopover.innerHTML = content;
        }

        function toggleMemoPad() {
            const memoPopover = document.getElementById('memo-popover');
            const currentDisplay = window.getComputedStyle(memoPopover).display;

            if (currentDisplay === 'none') {
                displayMemoPadContent(currentPlayer);
                memoPopover.style.display = 'block';
            } else {
                memoPopover.style.display = 'none';
            }
        }


        document.addEventListener("DOMContentLoaded", resetGame); // resetGame now initializes the placement phase
    </script>
</body>

</html>